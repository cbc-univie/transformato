import os
from openmm import MonteCarloMembraneBarostat
from openmm.app import (
    PME,
    AllBonds,
    CutoffNonPeriodic,
    CutoffPeriodic,
    Ewald,
    HAngles,
    HBonds,
    NoCutoff,
    Simulation,
)
from openmm import (
    CustomBondForce,
    CustomCentroidBondForce,
    CustomExternalForce,
    CustomNonbondedForce,
    CustomTorsionForce,
    MonteCarloAnisotropicBarostat,
    MonteCarloBarostat,
    NonbondedForce,
)
from openmm.unit import bar, kelvin, nanometers


#############################################################
#############################################################
# -------------------- taken from C-GUI ---------------------
#############################################################
#############################################################
"""
Generated by CHARMM-GUI (http://www.charmm-gui.org)
"""


def vfswitch(system, psf, inputs):
    r_on = inputs.r_on
    r_off = inputs.r_off

    # custom nonbonded force for force-switch
    chknbfix = False
    for force in system.getForces():
        if isinstance(force, NonbondedForce):
            nonbonded = force
        if (
            isinstance(force, CustomNonbondedForce)
            and force.getNumTabulatedFunctions() == 2
        ):
            nbfix = force
            chknbfix = True

    # vfswitch
    vfswitch = CustomNonbondedForce(
        "step(Ron-r)*(ccnba*tr6*tr6-ccnbb*tr6+ccnbb*onoff3-ccnba*onoff6) \
                                     +step(r-Ron)*step(Roff-r)*(cr12*rjunk6 - cr6*rjunk3) \
                                     -step(r-Ron)*step(Ron-r)*(cr12*rjunk6 - cr6*rjunk3); \
                                     cr6  = ccnbb*ofdif3*rjunk3; \
                                     cr12 = ccnba*ofdif6*rjunk6; \
                                     rjunk3 = r3-recof3; \
                                     rjunk6 = tr6-recof6; \
                                     r3 = r1*tr2; \
                                     r1 = sqrt(tr2); \
                                     tr6 = tr2 * tr2 * tr2; \
                                     tr2 = 1.0/s2; \
                                     s2 = r*r; \
                                     ccnbb = 4.0*epsilon*sigma^6; \
                                     ccnba = 4.0*epsilon*sigma^12; \
                                     sigma = sigma1+sigma2; \
                                     epsilon = epsilon1*epsilon2; \
                                     onoff3 = recof3/on3; \
                                     onoff6 = recof6/on6; \
                                     ofdif3 = off3/(off3 - on3); \
                                     ofdif6 = off6/(off6 - on6); \
                                     recof3 = 1.0/off3; \
                                     on6 = on3*on3; \
                                     on3 = c2onnb*Ron; \
                                     recof6 = 1.0/off6; \
                                     off6 = off3*off3; \
                                     off3 = c2ofnb*Roff; \
                                     c2ofnb = Roff*Roff; \
                                     c2onnb = Ron*Ron; \
                                     Ron  = %f; \
                                     Roff = %f;"
        % (r_on, r_off)
    )
    vfswitch.addPerParticleParameter("sigma")
    vfswitch.addPerParticleParameter("epsilon")
    vfswitch.setNonbondedMethod(vfswitch.CutoffPeriodic)
    vfswitch.setCutoffDistance(nonbonded.getCutoffDistance())
    for i in range(nonbonded.getNumParticles()):
        chg, sig, eps = nonbonded.getParticleParameters(i)
        nonbonded.setParticleParameters(i, chg, 0.0, 0.0)  # zero-out LJ
        sig = sig * 0.5
        eps = eps ** 0.5
        vfswitch.addParticle([sig, eps])
    for i in range(nonbonded.getNumExceptions()):
        atom1, atom2 = nonbonded.getExceptionParameters(i)[:2]
        vfswitch.addExclusion(atom1, atom2)
    vfswitch.setForceGroup(psf.NONBONDED_FORCE_GROUP)
    system.addForce(vfswitch)

    # vfswitch14
    vfswitch14 = CustomBondForce(
        "step(Ron-r)*(ccnba*tr6*tr6-ccnbb*tr6+ccnbb*onoff3-ccnba*onoff6) \
                                  +step(r-Ron)*step(Roff-r)*(cr12*rjunk6 - cr6*rjunk3) \
                                  -step(r-Ron)*step(Ron-r)*(cr12*rjunk6 - cr6*rjunk3); \
                                  cr6  = ccnbb*ofdif3*rjunk3; \
                                  cr12 = ccnba*ofdif6*rjunk6; \
                                  rjunk3 = r3-recof3; \
                                  rjunk6 = tr6-recof6; \
                                  r3 = r1*tr2; \
                                  r1 = sqrt(tr2); \
                                  tr6 = tr2 * tr2 * tr2; \
                                  tr2 = 1.0/s2; \
                                  s2 = r*r; \
                                  ccnbb = 4.0*epsilon*sigma^6; \
                                  ccnba = 4.0*epsilon*sigma^12; \
                                  onoff3 = recof3/on3; \
                                  onoff6 = recof6/on6; \
                                  ofdif3 = off3/(off3 - on3); \
                                  ofdif6 = off6/(off6 - on6); \
                                  recof3 = 1.0/off3; \
                                  on6 = on3*on3; \
                                  on3 = c2onnb*Ron; \
                                  recof6 = 1.0/off6; \
                                  off6 = off3*off3; \
                                  off3 = c2ofnb*Roff; \
                                  c2ofnb = Roff*Roff; \
                                  c2onnb = Ron*Ron; \
                                  Ron  = %f; \
                                  Roff = %f;"
        % (r_on, r_off)
    )
    vfswitch14.addPerBondParameter("sigma")
    vfswitch14.addPerBondParameter("epsilon")
    for i in range(nonbonded.getNumExceptions()):
        atom1, atom2, chg, sig, eps = nonbonded.getExceptionParameters(i)
        nonbonded.setExceptionParameters(
            i, atom1, atom2, chg, 0.0, 0.0
        )  # zero-out LJ14
        vfswitch14.addBond(atom1, atom2, [sig, eps])
    system.addForce(vfswitch14)

    # vfswitch_NBFIX
    if chknbfix:
        nbfix.setEnergyFunction(
            "step(Ron-r)*(ccnba*tr6*tr6-ccnbb*tr6+ccnbb*onoff3-ccnba*onoff6) \
                                 +step(r-Ron)*step(Roff-r)*(cr12*rjunk6 - cr6*rjunk3) \
                                 -step(r-Ron)*step(Ron-r)*(cr12*rjunk6 - cr6*rjunk3); \
                                 cr6  = ccnbb*ofdif3*rjunk3; \
                                 cr12 = ccnba*ofdif6*rjunk6; \
                                 rjunk3 = r3-recof3; \
                                 rjunk6 = tr6-recof6; \
                                 r3 = r1*tr2; \
                                 r1 = sqrt(tr2); \
                                 tr6 = tr2 * tr2 * tr2; \
                                 tr2 = 1.0/s2; \
                                 s2 = r*r; \
                                 ccnbb = bcoef(type1, type2); \
                                 ccnba = acoef(type1, type2)^2; \
                                 onoff3 = recof3/on3; \
                                 onoff6 = recof6/on6; \
                                 ofdif3 = off3/(off3 - on3); \
                                 ofdif6 = off6/(off6 - on6); \
                                 recof3 = 1.0/off3; \
                                 on6 = on3*on3; \
                                 on3 = c2onnb*Ron; \
                                 recof6 = 1.0/off6; \
                                 off6 = off3*off3; \
                                 off3 = c2ofnb*Roff; \
                                 c2ofnb = Roff*Roff; \
                                 c2onnb = Ron*Ron; \
                                 Ron  = %f; \
                                 Roff = %f;"
            % (r_on, r_off)
        )

        # turn off long range correction (OpenMM Issues: #2353)
        nbfix.setUseLongRangeCorrection(False)

    return system


def restraints(system, crd, inputs):

    boxlx = system.getDefaultPeriodicBoxVectors()[0][0].value_in_unit(nanometers)
    boxly = system.getDefaultPeriodicBoxVectors()[1][1].value_in_unit(nanometers)
    boxlz = system.getDefaultPeriodicBoxVectors()[2][2].value_in_unit(nanometers)

    if inputs.fc_bb > 0 or inputs.fc_sc > 0:
        # positional restraints for protein
        posresPROT = CustomExternalForce("k*periodicdistance(x, y, z, x0, y0, z0)^2;")
        posresPROT.addPerParticleParameter("k")
        posresPROT.addPerParticleParameter("x0")
        posresPROT.addPerParticleParameter("y0")
        posresPROT.addPerParticleParameter("z0")
        for line in open("restraints/prot_pos.txt", "r"):
            segments = line.strip().split()
            atom1 = int(segments[0])
            state = segments[1]
            xpos = crd.positions[atom1].value_in_unit(nanometers)[0]
            ypos = crd.positions[atom1].value_in_unit(nanometers)[1]
            zpos = crd.positions[atom1].value_in_unit(nanometers)[2]
            if state == "BB" and inputs.fc_bb > 0:
                fc_ppos = inputs.fc_bb
                posresPROT.addParticle(atom1, [fc_ppos, xpos, ypos, zpos])
            if state == "SC" and inputs.fc_sc > 0:
                fc_ppos = inputs.fc_sc
                posresPROT.addParticle(atom1, [fc_ppos, xpos, ypos, zpos])
        system.addForce(posresPROT)

    if inputs.fc_mpos > 0:
        # positional restraints for micelle lipid head group
        posresMICE = CustomExternalForce("k*periodicdistance(x, y, z, x0, y0, z0)^2;")
        posresMICE.addGlobalParameter("k", inputs.fc_mpos)
        posresMICE.addPerParticleParameter("x0")
        posresMICE.addPerParticleParameter("y0")
        posresMICE.addPerParticleParameter("z0")
        for line in open("restraints/lipid_pos.txt", "r"):
            segments = line.strip().split()
            atom1 = int(segments[0])
            xpos = crd.positions[atom1].value_in_unit(nanometers)[0]
            ypos = crd.positions[atom1].value_in_unit(nanometers)[1]
            zpos = crd.positions[atom1].value_in_unit(nanometers)[2]
            posresMICE.addParticle(atom1, [xpos, ypos, zpos])
        system.addForce(posresMICE)

    if inputs.fc_lpos > 0:
        # positional restraints for bilayer lipid head group
        posresMEMB = CustomExternalForce("k*periodicdistance(0, 0, z, 0, 0, z0)^2;")
        posresMEMB.addGlobalParameter("k", inputs.fc_lpos)
        posresMEMB.addPerParticleParameter("z0")
        for line in open("restraints/lipid_pos.txt", "r"):
            segments = line.strip().split()
            atom1 = int(segments[0])
            zpos = crd.positions[atom1].value_in_unit(nanometers)[2]
            posresMEMB.addParticle(atom1, [zpos])
        system.addForce(posresMEMB)

    if inputs.fc_hmmm > 0:
        posresHMMM = CustomCentroidBondForce(1, "k*(z1 - z0)^2")
        posresHMMM.addGlobalParameter("k", inputs.fc_hmmm)
        posresHMMM.addPerBondParameter("z0")

        # add groups and bonds
        for i, line in enumerate(open("restraints/hmmm_pos.txt", "r")):
            segments = line.strip().split()
            atoms = list(map(int, segments[:-1]))
            zpos = float(segments[-1]) + boxlz / 2.0
            posresHMMM.addGroup(atoms)
            posresHMMM.addBond([i], [zpos])
        posresHMMM.setUsesPeriodicBoundaryConditions(True)
        system.addForce(posresHMMM)

    if inputs.fc_dcle > 0:
        posresDCLE = CustomCentroidBondForce(
            1,
            "k*dr^2; \
                                                dr=max(0, r-rfb); \
                                                r=abs(z1 - z0);",
        )
        posresDCLE.addGlobalParameter("k", inputs.fc_dcle)
        posresDCLE.addGlobalParameter("rfb", inputs.fbres_rfb)
        posresDCLE.addGlobalParameter("z0", boxlz / 2.0)

        # add groups and bonds
        for i, line in enumerate(open("restraints/dcle_pos.txt", "r")):
            atoms = list(map(int, line.strip().split()))
            posresDCLE.addGroup(atoms)
            posresDCLE.addBond([i])
        posresDCLE.setUsesPeriodicBoundaryConditions(True)
        system.addForce(posresDCLE)

    if inputs.fc_ldih > 0:
        # dihedral restraints for lipids
        dihresMEMB = CustomTorsionForce(
            "fc_ldih*max(0, abs(diff+wrap) - rwidth)^2; \
                                         wrap = 2*pi*(step(-diff-pi)-step(diff-pi)); \
                                         diff = theta - rtheta0; \
                                         rtheta0 = theta0*pi/180; \
                                         rwidth = width*pi/180;"
        )
        dihresMEMB.addGlobalParameter("fc_ldih", inputs.fc_ldih)
        dihresMEMB.addGlobalParameter("pi", 3.141592653589793)
        dihresMEMB.addPerTorsionParameter("width")
        dihresMEMB.addPerTorsionParameter("theta0")
        for line in open("restraints/dihe.txt", "r"):
            segments = line.strip().split()
            atom1 = int(segments[0])
            atom2 = int(segments[1])
            atom3 = int(segments[2])
            atom4 = int(segments[3])
            theta0 = float(segments[4])
            width = float(segments[5])
            dihresMEMB.addTorsion(atom1, atom2, atom3, atom4, [width, theta0])
        system.addForce(dihresMEMB)

    if inputs.fc_cdih > 0:
        # dihedral restraints for carbohydrates
        dihresCARB = CustomTorsionForce(
            "fc_cdih*max(0, abs(diff+wrap) - rwidth)^2; \
                                         wrap = 2*pi*(step(-diff-pi)-step(diff-pi)); \
                                         diff = theta - rtheta0; \
                                         rtheta0 = theta0*pi/180; \
                                         rwidth = width*pi/180;"
        )
        dihresCARB.addGlobalParameter("fc_cdih", inputs.fc_cdih)
        dihresCARB.addGlobalParameter("pi", 3.141592653589793)
        dihresCARB.addPerTorsionParameter("width")
        dihresCARB.addPerTorsionParameter("theta0")
        if os.path.isfile("restraints/carbohydrate_restraint.dat"):
            for line in open("restraints/carbohydrate_restraint.dat", "r"):
                segments = line.strip().split()
                atom1 = int(segments[0])
                atom2 = int(segments[1])
                atom3 = int(segments[2])
                atom4 = int(segments[3])
                theta0 = float(segments[4])
                width = float(segments[5])
                dihresCARB.addTorsion(atom1, atom2, atom3, atom4, [width, theta0])
        if os.path.isfile("restraints/detergent_carbohydrate_restraint.dat"):
            for line in open("restraints/detergent_carbohydrate_restraint.dat", "r"):
                segments = line.strip().split()
                atom1 = int(segments[0])
                atom2 = int(segments[1])
                atom3 = int(segments[2])
                atom4 = int(segments[3])
                theta0 = float(segments[4])
                width = float(segments[5])
                dihresCARB.addTorsion(atom1, atom2, atom3, atom4, [width, theta0])
        system.addForce(dihresCARB)

    return system


def gen_box(psf, crd):
    coords = crd.positions

    min_crds = [coords[0][0], coords[0][1], coords[0][2]]
    max_crds = [coords[0][0], coords[0][1], coords[0][2]]

    for coord in coords:
        min_crds[0] = min(min_crds[0], coord[0])
        min_crds[1] = min(min_crds[1], coord[1])
        min_crds[2] = min(min_crds[2], coord[2])
        max_crds[0] = max(max_crds[0], coord[0])
        max_crds[1] = max(max_crds[1], coord[1])
        max_crds[2] = max(max_crds[2], coord[2])

    boxlx = max_crds[0] - min_crds[0]
    boxly = max_crds[1] - min_crds[1]
    boxlz = max_crds[2] - min_crds[2]

    psf.setBox(boxlx, boxly, boxlz)
    return psf


class _OpenMMReadInputs:
    def __init__(self):
        self.mini_nstep = 0  # Number of steps for minimization
        self.mini_Tol = 1.0  # Minimization energy tolerance
        self.gen_vel = "no"  # Generate initial velocities
        self.gen_temp = 300.0  # Temperature for generating initial velocities (K)
        self.gen_seed = None  # Seed for generating initial velocities
        self.nstep = 0  # Number of steps to run
        self.dt = 0.002  # Time-step (ps)

        self.nstout = 100  # Writing output frequency (steps)
        self.nstdcd = 0  # Wrtiing coordinates trajectory frequency (steps)

        self.coulomb = PME  # Electrostatic cut-off method
        self.ewald_Tol = 0.0005  # Ewald error tolerance
        self.vdw = "Force-switch"  # vdW cut-off method
        self.r_on = 1.0  # Switch-on distance (nm)
        self.r_off = 1.2  # Switch-off distance (nm)
        self.lj_lrc = "no"  # Turn on/off LJ long-range correction
        self.e14scale = 1.0  # 1-4 electrostatic interaction scaling

        self.temp = 300.0  # Temperature (K)
        self.fric_coeff = 1  # Friction coefficient for Langevin dynamics

        self.pcouple = "no"  # Turn on/off pressure coupling
        self.p_ref = 1.0  # Pressure (Pref or Pxx, Pyy, Pzz; bar)
        self.p_type = "membrane"  # MonteCarloBarotat type
        self.p_scale = True, True, True  # For MonteCarloAnisotropicBarostat
        self.p_XYMode = (
            MonteCarloMembraneBarostat.XYIsotropic
        )  # For MonteCarloMembraneBarostat
        self.p_ZMode = (
            MonteCarloMembraneBarostat.ZFree
        )  # For MonteCarloMembraneBarostat
        self.p_tens = 0.0  # Sulface tension for MonteCarloMembraneBarostat (dyne/cm)
        self.p_freq = 15  # Pressure coupling frequency (steps)

        self.cons = HBonds  # Constraints method

        self.rest = "no"  # Turn on/off restraints
        self.fc_bb = 0.0  # Positional restraint force constant for protein backbone (kJ/mol/nm^2)
        self.fc_sc = 0.0  # Positional restraint force constant for protein side-chain (kJ/mol/nm^2)
        self.fc_mpos = (
            0.0  # Positional restraint force constant for micelle lipids (kJ/mol/nm^2)
        )
        self.fc_lpos = (
            0.0  # Positional restraint force constant for lipids (kJ/mol/nm^2)
        )
        self.fc_hmmm = 0.0  # Planar restraint force constant for HMMM (kJ/mol/nm^2)
        self.fc_dcle = 0.0  # Flat-bottomed positional restraint force constant for HMMM DCLE (kJ/mol/nm^2)
        self.fc_ldih = (
            0.0  # Dihedral restraint force constant for lipids (kJ/mol/rad^2)
        )
        self.fc_cdih = (
            0.0  # Dihedral restraint force constant for carbohydrates (kJ/mol/rad^2)
        )
        self.fbres_rfb = (
            1.0  # Distance from the center for flat-bottomed positional restraint (nm)
        )

        self.annealing = "no"  # Turn on/off simulated annealing
        self.temp_init = 0.0  # Inital temperature of simulated annealing
        self.interval = 0.0  # Annealing temperature increment

    def read(self, inputFile):
        for line in open(inputFile, "r"):
            if line.find("#") >= 0:
                line = line.split("#")[0]
            line = line.strip()
            if len(line) > 0:
                segments = line.split("=")
                input_param = segments[0].upper().strip()
                try:
                    input_value = segments[1].strip()
                except:
                    input_value = None
                if input_value:
                    if input_param == "MINI_NSTEP":
                        self.mini_nstep = int(input_value)
                    if input_param == "MINI_TOL":
                        self.mini_Tol = float(input_value)
                    if input_param == "GEN_VEL":
                        if input_value.upper() == "YES":
                            self.gen_vel = "yes"
                        if input_value.upper() == "NO":
                            self.gen_vel = "no"
                    if input_param == "GEN_TEMP":
                        self.gen_temp = float(input_value)
                    if input_param == "GEN_SEED":
                        self.gen_seed = int(input_value)
                    if input_param == "NSTEP":
                        self.nstep = int(input_value)
                    if input_param == "DT":
                        self.dt = float(input_value)
                    if input_param == "NSTOUT":
                        self.nstout = int(input_value)
                    if input_param == "NSTDCD":
                        self.nstdcd = int(input_value)
                    if input_param == "COULOMB":
                        if input_value.upper() == "NOCUTOFF":
                            self.coulomb = NoCutoff
                        if input_value.upper() == "CUTOFFNONPERIODIC":
                            self.coulomb = CutoffNonPeriodic
                        if input_value.upper() == "CUTOFFPERIODIC":
                            self.coulomb = CutoffPeriodic
                        if input_value.upper() == "EWALD":
                            self.coulomb = Ewald
                        if input_value.upper() == "PME":
                            self.coulomb = PME
                    if input_param == "EWALD_TOL":
                        self.ewald_Tol = float(input_value)
                    if input_param == "VDW":
                        if input_value.upper() == "CUTOFFPERIODIC":
                            self.vdw = "CutoffPeriodic"
                        if input_value.upper() == "FORCE-SWITCH":
                            self.vdw = "Force-switch"
                        if input_value.upper() == "SWITCH":
                            self.vdw = "Switch"
                        if input_value.upper() == "LJPME":
                            self.vdw = "LJPME"
                    if input_param == "R_ON":
                        self.r_on = float(input_value)
                    if input_param == "R_OFF":
                        self.r_off = float(input_value)
                    if input_param == "LJ_LRC":
                        if input_value.upper() == "YES":
                            self.lj_lrc = "yes"
                        if input_value.upper() == "NO":
                            self.lj_lrc = "no"
                    if input_param == "E14SCALE":
                        self.e14scale = float(input_value)
                    if input_param == "TEMP":
                        self.temp = float(input_value)
                    if input_param == "FRIC_COEFF":
                        self.fric_coeff = float(input_value)
                    if input_param == "PCOUPLE":
                        if input_value.upper() == "YES":
                            self.pcouple = "yes"
                        if input_value.upper() == "NO":
                            self.pcouple = "no"
                    if input_param == "P_REF":
                        if input_value.find(",") < 0:
                            self.p_ref = float(input_value)
                        else:
                            Pxx = float(input_value.split(",")[0])
                            Pyy = float(input_value.split(",")[1])
                            Pzz = float(input_value.split(",")[2])
                            self.p_ref = Pxx, Pyy, Pzz
                    if input_param == "P_TYPE":
                        if input_value.upper() == "ISOTROPIC":
                            self.p_type = "isotropic"
                        if input_value.upper() == "MEMBRANE":
                            self.p_type = "membrane"
                        if input_value.upper() == "ANISOTROPIC":
                            self.p_type = "anisotropic"
                    if input_param == "P_SCALE":
                        scaleX = True
                        scaleY = True
                        scaleZ = True
                        if input_value.upper().find("X") < 0:
                            scaleX = False
                        if input_value.upper().find("Y") < 0:
                            scaleY = False
                        if input_value.upper().find("Z") < 0:
                            scaleZ = False
                        self.p_scale = scaleX, scaleY, scaleZ
                    if input_param == "P_XYMODE":
                        if input_value.upper() == "XYISOTROPIC":
                            self.p_XYMode = MonteCarloMembraneBarostat.XYIsotropic
                        if input_value.upper() == "XYANISOTROPIC":
                            self.p_XYMode = MonteCarloMembraneBarostat.XYAnisotropic
                    if input_param == "P_ZMODE":
                        if input_value.upper() == "ZFREE":
                            self.p_ZMode = MonteCarloMembraneBarostat.ZFree
                        if input_value.upper() == "ZFIXED":
                            self.p_ZMode = MonteCarloMembraneBarostat.ZFixed
                        if input_value.upper() == "CONSTANTVOLUME":
                            self.p_ZMode = MonteCarloMembraneBarostat.ConstantVolume
                    if input_param == "P_TENS":
                        self.p_tens = float(input_value)
                    if input_param == "P_FREQ":
                        self.p_freq = int(input_value)
                    if input_param == "CONS":
                        if input_value.upper() == "NONE":
                            self.cons = None
                        if input_value.upper() == "HBONDS":
                            self.cons = HBonds
                        if input_value.upper() == "ALLBONDS":
                            self.cons = AllBonds
                        if input_value.upper() == "HANGLES":
                            self.cons = HAngles
                    if input_param == "REST":
                        if input_value.upper() == "YES":
                            self.rest = "yes"
                        if input_value.upper() == "NO":
                            self.rest = "no"
                    if input_param == "FC_BB":
                        self.fc_bb = float(input_value)
                    if input_param == "FC_SC":
                        self.fc_sc = float(input_value)
                    if input_param == "FC_MPOS":
                        self.fc_mpos = float(input_value)
                    if input_param == "FC_LPOS":
                        self.fc_lpos = float(input_value)
                    if input_param == "FC_HMMM":
                        self.fc_hmmm = float(input_value)
                    if input_param == "FC_DCLE":
                        self.fc_dcle = float(input_value)
                    if input_param == "FC_LDIH":
                        self.fc_ldih = float(input_value)
                    if input_param == "FC_CDIH":
                        self.fc_cdih = float(input_value)
                    if input_param == "FBRES_RFB":
                        self.fbres_rfb = float(input_value)
                    if input_param == "ANNEALING":
                        if input_value.upper() == "YES":
                            self.annealing = "yes"
                    if input_param == "TEMP_INIT":
                        self.temp_init = float(input_value)
                    if input_param == "INTERVAL":
                        self.interval = float(input_value)
        return self


def read_inputs(inputFile):
    return _OpenMMReadInputs().read(inputFile)


def barostat(system, inputs):

    if inputs.p_type == "isotropic":
        barostat = MonteCarloBarostat(inputs.p_ref * bar, inputs.temp * kelvin)
    if inputs.p_type == "membrane":
        inputs.p_tens = inputs.p_tens * 10.0
        barostat = MonteCarloMembraneBarostat(
            inputs.p_ref * bar,
            inputs.p_tens * bar * nanometers,
            inputs.temp * kelvin,
            inputs.p_XYMode,
            inputs.p_ZMode,
            inputs.p_freq,
        )
    if inputs.p_type == "anisotropic":
        barostat = MonteCarloAnisotropicBarostat(
            inputs.p_ref * bar,
            inputs.temp * kelvin,
            inputs.p_scale[0],
            inputs.p_scale[1],
            inputs.p_scale[2],
            inputs.p_freq,
        )

    system.addForce(barostat)

    return system


#############################################################
#############################################################
#############################################################
# --------------------- Test start --------------------------
#############################################################
#############################################################
#############################################################
